package com.subway.chatbotservice.service;

import com.subway.chatbotservice.dto.ChatRequest;
import com.subway.chatbotservice.dto.ChatResponse;
import com.subway.chatbotservice.entity.ChatHistory;
import com.subway.chatbotservice.repository.ChatHistoryRepository;
import com.subway.chatbotservice.service.IntentClassifier.IntentResult;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.Map;
import java.util.UUID;

@Slf4j
@Service
@RequiredArgsConstructor
public class ChatbotService {

    private final OllamaService ollamaService;
    private final IntentClassifier intentClassifier;
    private final DataFetchService dataFetchService;
    private final ChatHistoryRepository chatHistoryRepository;

    @Value("${ollama.enabled:false}")
    private boolean ollamaEnabled;

    public ChatResponse chat(ChatRequest request) {
        long startTime = System.currentTimeMillis();

        IntentResult intentResult = intentClassifier.classify(request.getMessage());
        log.info("Intent classified: {}", intentResult.getIntent());

        Object data = fetchData(intentResult);

        String response;
        if (ollamaEnabled) {
            try {
                String prompt = buildPrompt(request.getMessage(), intentResult, data);
                response = ollamaService.generate(prompt);
                log.info("Response generated by Ollama");
            } catch (Exception e) {
                log.error("Ollama failed, using fallback: {}", e.getMessage());
                response = generateFallbackResponse(request.getMessage(), intentResult, data);
            }
        } else {
            log.info("Ollama disabled, using fallback response");
            response = generateFallbackResponse(request.getMessage(), intentResult, data);
        }

        long responseTime = System.currentTimeMillis() - startTime;

        String sessionId = request.getSessionId() != null ?
                request.getSessionId() : UUID.randomUUID().toString();

        saveChatHistory(request, response, intentResult, sessionId, responseTime);

        return ChatResponse.builder()
                .message(response)
                .intent(intentResult.getIntent())
                .sessionId(sessionId)
                .timestamp(LocalDateTime.now())
                .responseTimeMs(responseTime)
                .build();
    }

    private Object fetchData(IntentResult intentResult) {
        String intent = intentResult.getIntent();
        String lineNumber = intentResult.getLineNumber();
        String stationName = intentResult.getStationName();

        if (stationName != null && !stationName.endsWith("역")) {
            stationName = stationName + "역";
        }

        log.info("Fetching data: intent={}, station={}, line={}", intent, stationName, lineNumber);

        switch (intent) {
            case "REALTIME_CONGESTION":
                return dataFetchService.fetchRealtimeCongestion(lineNumber, stationName);
            case "PREDICTION":
                return dataFetchService.fetchPrediction(lineNumber, stationName);
            case "STATISTICS":
                return dataFetchService.fetchStatistics(lineNumber, stationName);
            case "TOP_CONGESTED":
                return dataFetchService.fetchTopCongested(10);
            default:
                return null;
        }
    }

    private String buildPrompt(String userMessage, IntentResult intentResult, Object data) {
        StringBuilder prompt = new StringBuilder();
        prompt.append("당신은 친절한 지하철 혼잡도 안내 챗봇입니다.\n");
        prompt.append("사용자 질문: ").append(userMessage).append("\n\n");

        if (data != null) {
            prompt.append("실시간 데이터:\n");
            prompt.append(data.toString()).append("\n\n");
            prompt.append("위 데이터를 바탕으로 사용자에게 친절하고 자세하게 답변해주세요.");
        } else {
            prompt.append("데이터를 가져올 수 없습니다. 사용자에게 정중하게 알려주세요.");
        }

        return prompt.toString();
    }

    private String generateFallbackResponse(String userMessage, IntentResult intentResult, Object data) {
        String lowerMessage = userMessage.toLowerCase();
        String intent = intentResult.getIntent();

        switch (intent) {
            case "REALTIME_CONGESTION":
                if (data != null) {
                    return formatRealtimeData(data);
                } else {
                    return "죄송합니다. 현재 혼잡도 정보를 가져올 수 없습니다. 잠시 후 다시 시도해주세요.";
                }

            case "PREDICTION":
                if (data != null) {
                    return formatPredictionData(data);
                } else {
                    return "죄송합니다. 예측 정보를 가져올 수 없습니다.";
                }

            case "STATISTICS":
                if (data != null) {
                    return formatStatisticsData(data);
                } else {
                    return "죄송합니다. 통계 정보를 가져올 수 없습니다.";
                }

            case "TOP_CONGESTED":
                if (data != null) {
                    return String.format("혼잡도 TOP 역 정보입니다:\n\n%s", data.toString());
                } else {
                    return "죄송합니다. TOP 혼잡역 정보를 가져올 수 없습니다.";
                }

            case "GREETING":
                return "안녕하세요! 지하철 혼잡도 정보 챗봇입니다.\n\n"
                        + "다음과 같은 질문을 해보세요:\n"
                        + "• 강남역 혼잡도 알려줘\n"
                        + "• 2호선 홍대입구역 예측\n"
                        + "• 혼잡한 역 TOP 10";

            case "HELP":
                return "사용 가능한 기능:\n\n"
                        + "1. 실시간 혼잡도 조회\n"
                        + "2. 혼잡도 예측\n"
                        + "3. 통계 정보\n"
                        + "4. 혼잡도 TOP 역\n\n"
                        + "예시: '강남역 혼잡도', '2호선 신림역 예측'";

            default:
                if (lowerMessage.contains("안녕") || lowerMessage.contains("hello")) {
                    return "안녕하세요! 지하철 혼잡도 정보를 알려드립니다.";
                } else if (lowerMessage.contains("강남")) {
                    return "강남역 정보를 원하시나요? '강남역 혼잡도'라고 물어보세요!";
                } else if (lowerMessage.contains("홍대")) {
                    return "홍대입구역 정보를 원하시나요? '홍대입구역 혼잡도'라고 물어보세요!";
                } else {
                    return "죄송합니다. 이해하지 못했습니다.\n\n"
                            + "'역 이름 + 혼잡도' 형식으로 질문해주세요.\n"
                            + "예: 강남역 혼잡도, 신림역 예측";
                }
        }
    }


    private String formatRealtimeData(Object data) {
        if (data == null) {
            return "죄송합니다. 혼잡도 정보를 가져올 수 없습니다.";
        }

        if (data instanceof Map) {
            try {
                Map<String, Object> dataMap = (Map<String, Object>) data;

                // ✅ 안전한 값 추출
                String stationName = getStringValue(dataMap, "stationName", "알 수 없음");
                String lineNumber = getStringValue(dataMap, "lineNumber", "");
                Double congestionLevel = getDoubleValue(dataMap, "congestionLevel", 0.0);
                Integer passengerCount = getIntValue(dataMap, "passengerCount", 0);

                String status = getCongestionStatus(congestionLevel);
                String emoji = getCongestionEmoji(congestionLevel);

                StringBuilder response = new StringBuilder();
                response.append(emoji).append(" ").append(stationName);
                if (lineNumber != null && !lineNumber.isEmpty() && !lineNumber.equals("null")) {
                    response.append(" (").append(lineNumber).append("호선)");
                }
                response.append(" 실시간 혼잡도\n\n");
                response.append("혼잡도: ").append(String.format("%.1f%%", congestionLevel)).append("\n");
                response.append("승객 수: 약 ").append(passengerCount).append("명\n");
                response.append("상태: ").append(status).append("\n\n");
                response.append(getAdvice(congestionLevel));

                return response.toString();
            } catch (Exception e) {
                log.error("Error formatting realtime data: {}", e.getMessage());
                return "혼잡도 정보를 표시하는 중 오류가 발생했습니다.";
            }
        }

        return "실시간 혼잡도 정보:\n\n" + data.toString();
    }

    // ✅ 안전한 값 추출 헬퍼 메서드들
    private String getStringValue(Map<String, Object> map, String key, String defaultValue) {
        Object value = map.get(key);
        if (value == null) {
            return defaultValue;
        }
        return value.toString();
    }

    private Double getDoubleValue(Map<String, Object> map, String key, Double defaultValue) {
        Object value = map.get(key);
        if (value == null) {
            return defaultValue;
        }
        if (value instanceof Number) {
            return ((Number) value).doubleValue();
        }
        try {
            return Double.parseDouble(value.toString());
        } catch (NumberFormatException e) {
            return defaultValue;
        }
    }

    private Integer getIntValue(Map<String, Object> map, String key, Integer defaultValue) {
        Object value = map.get(key);
        if (value == null) {
            return defaultValue;
        }
        if (value instanceof Number) {
            return ((Number) value).intValue();
        }
        try {
            return Integer.parseInt(value.toString());
        } catch (NumberFormatException e) {
            return defaultValue;
        }
    }

    private String getCongestionStatus(Double congestionLevel) {
        if (congestionLevel >= 80) return "매우 혼잡";
        if (congestionLevel >= 60) return "혼잡";
        if (congestionLevel >= 40) return "보통";
        return "여유";
    }

    private String getCongestionEmoji(Double congestionLevel) {
        if (congestionLevel >= 80) return "[매우혼잡]";
        if (congestionLevel >= 60) return "[혼잡]";
        if (congestionLevel >= 40) return "[보통]";
        return "[여유]";
    }

    private String getAdvice(Double congestionLevel) {
        if (congestionLevel >= 80) {
            return "매우 혼잡합니다. 다음 열차를 이용하거나 다른 시간대를 고려해보세요.";
        } else if (congestionLevel >= 60) {
            return "혼잡한 편입니다. 조금 기다리시면 더 쾌적할 수 있어요.";
        } else if (congestionLevel >= 40) {
            return "적당한 혼잡도입니다. 이용하기 괜찮은 시간대예요!";
        } else {
            return "매우 여유롭습니다. 지금이 이용하기 좋은 시간이에요!";
        }
    }

    private String formatPredictionData(Object data) {
        if (data == null) {
            return "죄송합니다. 예측 정보를 가져올 수 없습니다.";
        }

        if (data instanceof Map) {
            try {
                Map<String, Object> dataMap = (Map<String, Object>) data;

                String stationName = getStringValue(dataMap, "stationName", "알 수 없음");
                Double predictedCongestion = getDoubleValue(dataMap, "predictedCongestion", 0.0);
                String predictedTime = getStringValue(dataMap, "predictedTime", "30분 후");

                String emoji = getCongestionEmoji(predictedCongestion);

                StringBuilder response = new StringBuilder();
                response.append(stationName).append(" 혼잡도 예측\n\n");
                response.append("시간: ").append(predictedTime).append("\n");
                response.append("예상 혼잡도: ").append(String.format("%.1f%%", predictedCongestion)).append(" ").append(emoji).append("\n\n");
                response.append(getAdvice(predictedCongestion));

                return response.toString();
            } catch (Exception e) {
                log.error("Error formatting prediction data: {}", e.getMessage());
                return "예측 정보를 표시하는 중 오류가 발생했습니다.";
            }
        }

        return "혼잡도 예측 정보:\n\n" + data.toString();
    }

    private String formatStatisticsData(Object data) {
        if (data == null) {
            return "죄송합니다. 통계 정보를 가져올 수 없습니다.";
        }

        if (data instanceof Map) {
            try {
                Map<String, Object> dataMap = (Map<String, Object>) data;

                String stationName = getStringValue(dataMap, "stationName", "알 수 없음");
                Double avgCongestion = getDoubleValue(dataMap, "avgCongestion", 0.0);
                String peakTime = getStringValue(dataMap, "peakTime", "오전 8시");

                StringBuilder response = new StringBuilder();
                response.append(stationName).append(" 통계 정보\n\n");
                response.append("평균 혼잡도: ").append(String.format("%.1f%%", avgCongestion)).append("\n");
                response.append("피크 시간: ").append(peakTime).append("\n\n");
                response.append("가능하면 피크 시간을 피해 이용하시는 것을 추천드립니다!");

                return response.toString();
            } catch (Exception e) {
                log.error("Error formatting statistics data: {}", e.getMessage());
                return "통계 정보를 표시하는 중 오류가 발생했습니다.";
            }
        }

        return "통계 정보:\n\n" + data.toString();
    }

    private Double parseDouble(Object value) {
        if (value == null) return 0.0;
        if (value instanceof Number) return ((Number) value).doubleValue();
        try {
            return Double.parseDouble(value.toString());
        } catch (NumberFormatException e) {
            return 0.0;
        }
    }

    private Integer parseInt(Object value) {
        if (value == null) return 0;
        if (value instanceof Number) return ((Number) value).intValue();
        try {
            return Integer.parseInt(value.toString());
        } catch (NumberFormatException e) {
            return 0;
        }
    }


    private void saveChatHistory(ChatRequest request, String response,
                                 IntentResult intentResult, String sessionId, long responseTime) {
        try {
            ChatHistory history = ChatHistory.builder()
                    .sessionId(sessionId)
                    .userId(request.getUserId())
                    .userMessage(request.getMessage())
                    .botResponse(response)
                    .intent(intentResult.getIntent())
                    .lineNumber(intentResult.getLineNumber())
                    .stationName(intentResult.getStationName())
                    .timestamp(LocalDateTime.now())
                    .responseTimeMs(responseTime)
                    .build();

            chatHistoryRepository.save(history);
            log.info("Chat history saved: sessionId={}", sessionId);
        } catch (Exception e) {
            log.error("Failed to save chat history: {}", e.getMessage());
        }
    }
}
